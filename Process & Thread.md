# 프로세스 (Process)

- 개념: 프로세스는 실행 중인 프로그램의 인스턴스를 나타냅니다. 각 프로세스는 **독립적으로 실행되며, 자체 메모리 공간**을 가지고 있습니다. 따라서 다른 프로세스와 격리되어 있습니다.

- 메모리: 각 프로세스는 자체 메모리 공간을 가지며, 코드, 데이터, 스택 및 힙과 같은 요소로 구성됩니다. 이로 인해 한 프로세스가 다른 프로세스에 영향을 미치지 않고 독립적으로 실행될 수 있습니다.

 - Overhead: 프로세스 간 통신이나 협력이 필요한 경우, IPC(Inter-Process Communication) 메커니즘을 사용하여 데이터를 공유하거나 메시지를 교환해야 합니다. 이러한 과정에는 오버헤드가 발생할 수 있습니다.

 - 안정성: 하나의 프로세스가 충돌하면 다른 프로세스에 영향을 주지 않으므로 안정성이 높습니다.

------------------------------------------------------------------------------------------------------------------------------------------

### 스레드가 나오게된 배경

초기 컴퓨터 시스템에서는 한 번에 하나의 프로그램만 실행할 수 있었습니다. 이것을 단일 프로세스 환경이라고 합니다.

단일 프로세스 시스템에서는 하나의 프로그램이 CPU를 독점적으로 사용하고, 다른 프로그램을 실행하기 위해서는 현재 실행 중인 프로그램을 완전히 종료해야 했습니다.

이로 인해 다중 작업을 수행하기 위해 프로그램을 계속 시작하고 종료하는 불편함이 있었습니다.

스레드는 이러한 제약을 극복하기 위해 등장한 개념입니다.

여러 스레드를 가진 하나의 프로세스 내에서 각 스레드는 별도의 실행 흐름을 갖고 있지만, 같은 프로세스 내의 메모리를 공유합니다.

스레드는 프로세스 내에서 경량화된 실행 단위로, 여러 스레드가 동시에 작업을 수행하면서 CPU를 효율적으로 활용할 수 있게 합니다.

------------------------------------------------------------------------------------------------------------------------------------------


#  스레드 (Thread)

 - 개념: 스레드는 하나의 프로세스 내에서 실행되는 작은 실행 단위입니다. 스레드는 **동일한 프로세스의 메모리 공간을 공유하므로 스레드 간 데이터 공유가 쉽습니다.**

 - 메모리: 스레드는 프로세스 내에서 실행되므로 같은 프로세스 내의 다른 스레드와 메모리를 공유합니다. 이는 스레드 간의 데이터 공유와 효율적인 작업을 가능하게 합니다.

 - Overhead: 스레드 간 통신은 프로세스 간 통신보다 효율적이지만, 동기화 및 공유 자원 접근과 같은 문제로 인해 스레드 간에 충돌이 발생할 수 있습니다.

 - 안정성: 스레드는 같은 프로세스 내에서 실행되므로 하나의 스레드가 충돌하면 다른 스레드도 영향을 받을 수 있으므로 안정성에 주의해야 합니다.


### 스레드의 장점

 - 병렬성(Parallelism): 여러 스레드를 사용하여 여러 작업을 동시에 수행할 수 있으므로 작업 처리 속도가 향상됩니다.
 - 응답성(Responsiveness): 다중 스레드를 사용하면 한 스레드에서 블로킹 작업(예: 파일 입출력, 네트워크 통신)이 발생해도 다른 스레드가 계속 실행될 수 있어 시스템 응답성이 향상됩니다.
 - 자원 공유(Resource Sharing): 스레드는 같은 프로세스 내에서 메모리를 공유하므로 데이터 공유 및 효율적인 자원 관리가 가능합니다. (컨텍스트 스위칭이 가볍다)

------------------------------------------------------------------------------------------------------------------------------------------

## 멀티스레딩

멀티스레딩(Multithreading)은 하나의 프로세스 내에서 여러 스레드가 동시에 실행되는 프로그래밍 및 실행 모델을 의미합니다.

멀티스레딩은 다중 작업(multitasking) 및 병렬 처리(parallel processing)를 구현하는 데 사용되며, 다음과 같은 중요한 개념과 특징을 가지고 있습니다

------------------------------------------------------------------------------------------------------------------------------------------

 ### 특징

- 스레드 간 동기화(Synchronization)

  여러 스레드가 공유 데이터에 접근하거나 수정할 때 데이터 일관성을 유지하기 위해 스레드 간의 동기화가 필요합니다.
  
  락(lock)과 세마포어(semaphore) 등의 동기화 메커니즘을 사용하여 스레드 간의 접근을 제어합니다.

- 경쟁 조건(Race Condition)

  경쟁 조건은 여러 스레드가 공유 데이터를 동시에 접근할 때 발생하는 문제입니다.
  
  이러한 문제를 방지하기 위해 상호배제(mutual exclusion)을 구현하여 한 번에 하나의 스레드만 접근하도록 보호해야 합니다.

- 스레드 풀(Thread Pool) 및 작업 큐(Task Queue)

  멀티스레딩은 작업 처리를 효율적으로 관리하기 위해 스레드 풀과 작업 큐를 사용하는 경우가 많습니다. 
  
  스레드 풀은 미리 생성된 스레드 집합이며, 작업 큐에 작업을 넣고 스레드 풀에서 작업을 처리합니다.

- 멀티코어(CPU Core) 활용

 멀티스레딩은 멀티코어 프로세서에서 특히 효과적으로 작동합니다. 멀티코어 CPU는 여러 스레드를 병렬로 실행하여 성능을 향상시킬 수 있습니다.

- 주의사항

 멀티스레딩은 복잡한 디버깅과 스레드 간의 동기화 관리를 필요로 하므로 주의가 필요합니다. 
 
 경쟁 조건과 데드락(deadlock)과 같은 문제를 피하기 위한 좋은 설계 및 프로그래밍 관행을 따르는 것이 중요합니다.
 
 멀티스레딩은 다중 작업과 병렬 처리를 구현하기 위한 강력한 도구이며, 현대의 응용 프로그램과 시스템에서 널리 사용됩니다.

------------------------------------------------------------------------------------------------------------------------------------------

### 장점

- 성능 향상: 멀티스레딩은 여러 스레드가 동시에 작업을 수행하므로 CPU 활용도를 높일 수 있습니다.

- 응답성 향상: 스레드를 사용하면 한 스레드에서 블로킹 작업(예: 파일 입출력, 네트워크 통신)이 발생해도 다른 스레드가 계속 실행될 수 있어 시스템 응답성이 향상됩니다.

- 자원 공유: 스레드는 같은 프로세스 내에서 메모리를 공유하므로 데이터 공유 및 효율적인 자원 관리가 가능합니다.

------------------------------------------------------------------------------------------------------------------------------------------

### 생성과 실행

자바에서 스레드를 생성하는 방법에는 다음과 같이 두 가지 방법이 있습니다.

 

- Runnable 인터페이스를 구현하는 방법

- Thread 클래스를 상속받는 방법

 

두 방법 모두 스레드를 통해 작업하고 싶은 내용을 run() 메소드에 작성하면 됩니다.

 

다음 예제는 위의 두 가지 방법을 사용하여 스레드를 생성하고 실행하는 예제입니다.

```
class ThreadWithClass extends Thread {

    public void run() {

        for (int i = 0; i < 5; i++) {

            System.out.println(getName()); // 현재 실행 중인 스레드의 이름을 반환함.

            try {

                Thread.sleep(10);          // 0.01초간 스레드를 멈춤.

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        }

    }

}
```
 
```
class ThreadWithRunnable implements Runnable {

    public void run() {

        for (int i = 0; i < 5; i++) {

            System.out.println(Thread.currentThread().getName()); // 현재 실행 중인 스레드의 이름을 반환함.

            try {

                Thread.sleep(10);

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        }

    }

}
```
 
```
public class Thread01 {

    public static void main(String[] args){

        ThreadWithClass thread1 = new ThreadWithClass();       // Thread 클래스를 상속받는 방법

        Thread thread2 = new Thread(new ThreadWithRunnable()); // Runnable 인터페이스를 구현하는 방법

 

        thread1.start(); // 스레드의 실행

        thread2.start(); // 스레드의 실행

    }

}
```


실행 결과
```
Thread-0

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1
```

 

위 예제의 실행 결과를 살펴보면, 생성된 스레드가 서로 번갈아가며 실행되고 있는 것을 확인할 수 있습니다.

 

Thread 클래스를 상속받으면 다른 클래스를 상속받을 수 없으므로, 일반적으로 Runnable 인터페이스를 구현하는 방법으로 스레드를 생성합니다.

 

Runnable 인터페이스는 몸체가 없는 메소드인 run() 메소드 단 하나만을 가지는 간단한 인터페이스입니다.

------------------------------------------------------------------------------------------------------------------------------------------

### 스레드의 우선순위

자바에서 각 스레드는 우선순위(priority)에 관한 자신만의 필드를 가지고 있습니다.

이러한 우선순위에 따라 특정 스레드가 더 많은 시간 동안 작업을 할 수 있도록 설정할 수 있습니다.

- 필드	설명

  - static int MAX_PRIORITY	스레드가 가질 수 있는 최대 우선순위를 명시함.
  - static int MIN_PRIORITY	스레드가 가질 수 있는 최소 우선순위를 명시함.
  - static int NORM_PRIORITY	스레드가 생성될 때 가지는 기본 우선순위를 명시함.
 

getPriority()와 setPriority() 메소드를 통해 스레드의 우선순위를 반환하거나 변경할 수 있습니다.

스레드의 우선순위가 가질 수 있는 범위는 1부터 10까지이며, 숫자가 높을수록 우선순위 또한 높아집니다.

 

하지만 스레드의 우선순위는 비례적인 절댓값이 아닌 어디까지나 상대적인 값일 뿐입니다.

우선순위가 10인 스레드가 우선순위가 1인 스레드보다 10배 더 빨리 수행되는 것이 아닙니다.

단지 우선순위가 10인 스레드는 우선순위가 1인 스레드보다 좀 더 많이 실행 큐에 포함되어, 좀 더 많은 작업 시간을 할당받을 뿐입니다.

 

그리고 스레드의 우선순위는 해당 스레드를 생성한 스레드의 우선순위를 상속받게 됩니다.

 

```
class ThreadWithRunnable implements Runnable {

    public void run() {

        for (int i = 0; i < 5; i++) {

            System.out.println(Thread.currentThread().getName()); // 현재 실행 중인 스레드의 이름을 반환함.

            try {

                Thread.sleep(10);

            } catch (InterruptedException e) {

                e.printStackTrace();

            }

        }

    }

}
```
 
```
public class Thread02 {

    public static void main(String[] args){

        Thread thread1 = new Thread(new ThreadWithRunnable());

        Thread thread2 = new Thread(new ThreadWithRunnable());

 

①      thread2.setPriority(10); // Thread-1의 우선순위를 10으로 변경함.

 

②      thread1.start(); // Thread-0 실행

③      thread2.start(); // Thread-1 실행

 

        System.out.println(thread1.getPriority());

        System.out.println(thread2.getPriority());

    }

}
```



실행 결과
```
5

10

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1

Thread-0

Thread-1

Thread-0
```
 

main() 메소드를 실행하는 스레드의 우선순위는 언제나 5이므로, main() 메소드 내에서 생성된 스레드 Thread-0의 우선순위는 5로 설정되는 것을 확인할 수 있습니다.

 

- 위의 예제는 ②번 라인에서 Thread-0이 먼저 실행되고, ③번 라인에서 Thread-1이 나중에 실행됩니다.

- 따라서 만약 ①번 라인이 존재하지 않는다면, Thread-0이 먼저 실행되고, Thread-1이 나중에 실행될 것입니다.

- 하지만 ①번 라인에서 Thread-1의 우선순위를 10으로 변경했기 때문에, Thread-1이 나중에 실행됐더라도 우선순위가 Thread-0보다 높아 먼저 실행되는 것입니다.
  
## 요약


 - 프로세스는 독립적인 실행 단위이며, 메모리를 분리하여 격리됩니다.
 - 스레드는 하나의 프로세스 내에서 실행되며, 메모리를 공유합니다.
 - 프로세스는 안정성이 높지만 오버헤드가 크며 IPC가 필요합니다.
 - 스레드는 오버헤드가 낮고 효율적인 데이터 공유를 가능하게 하지만 동기화에 주의해야 합니다.
 - 프로세스와 스레드는 다중 처리 및 병렬 프로그래밍에서 중요한 역할을 하며, 올바르게 관리하면 성능을 최적화하고 다양한 작업을 효율적으로 처리할 수 있습니다.
